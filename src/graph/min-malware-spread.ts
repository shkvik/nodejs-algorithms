function minMalwareSpread(graph: number[][], initial: number[]): number {
  const n = graph.length;
  const color = new Array(n).fill(-1);
  let colorIndex = 0;

  // Функция для поиска компонентов (DFS)
  function dfs(node: number, colorIndex: number) {
    color[node] = colorIndex;
    for (let neighbor = 0; neighbor < n; neighbor++) {
      if (graph[node][neighbor] === 1 && color[neighbor] === -1) {
        dfs(neighbor, colorIndex);
      }
    }
  }

  // Шаг 1: Определяем компоненты графа
  for (let i = 0; i < n; i++) {
    if (color[i] === -1) {
      dfs(i, colorIndex);
      colorIndex++;
    }
  }

  const componentSize = new Array(colorIndex).fill(0);
  const malwareCount = new Array(colorIndex).fill(0);

  // Шаг 2: Считаем размер каждой компоненты
  for (let i = 0; i < n; i++) {
    componentSize[color[i]]++;
  }

  // Шаг 3: Подсчитываем количество заражённых узлов в каждой компоненте
  for (const node of initial) {
    malwareCount[color[node]]++;
  }

  // Шаг 4: Ищем узел для удаления
  let result = -1;
  let maxSaved = -1;

  // Сортируем `initial` для выбора минимального индекса в случае одинакового результата
  initial.sort((a, b) => a - b);

  for (const node of initial) {
    const compIdx = color[node];
    if (malwareCount[compIdx] === 1) {
      const saved = componentSize[compIdx];
      if (saved > maxSaved) {
        maxSaved = saved;
        result = node;
      }
    }
  }

  // Если ни один узел не уменьшит количество заражённых, возвращаем минимальный индекс
  return result === -1 ? initial[0] : result;
}





export function minMalwareSpreadDBG() {
  const tests = [
    {
      input: {
        graph: [
          [1, 1, 0],
          [1, 1, 0],
          [0, 0, 1]
        ],
        initial: [0, 1]
      },
      expected: 0 // Удаление узла 0 минимизирует распространение
    },
    {
      input: {
        graph: [
          [1, 0, 0],
          [0, 1, 0],
          [0, 0, 1]
        ],
        initial: [0, 2]
      },
      expected: 0 // Удаление узла 0 минимизирует распространение
    },
    {
      input: {
        graph: [
          [1, 1, 1],
          [1, 1, 1],
          [1, 1, 1]
        ],
        initial: [0, 1, 2]
      },
      expected: 0 // Удаление любого узла не поможет, выбираем минимальный индекс
    }
  ];

  tests.forEach((testCase, index) => {
    const result = minMalwareSpread(testCase.input.graph, testCase.input.initial);
    const success = result === testCase.expected;
    if (success) {
      console.log(`Test ${index} success`);
    } else {
      console.log(`Test ${index} fail`);
      console.log(`expected: ${testCase.expected}`);
      console.log(`got: ${result}`);
    }
  });

}
